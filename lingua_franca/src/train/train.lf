/**
 * Taken from Lab 4 (Hill Climb).
 * Gets train to move on a line at a set speed
 */
 target C {
  platform: {
    name: "rp2040",
    board: "pololu_3pi_2040_robot"
  },
  single-threaded: true
}

import Line from "../lib/Line.lf"
import Display from "../lib/Display.lf"
import MotorsWithFeedback from "../lib/MotorsWithFeedback.lf"
import Encoders from "../lib/Encoders.lf"
import Accelerometer from "../lib/IMU.lf"

reactor Robot {
  preamble {=
    #include <math.h>
    #define WHEEL_DIAMETER 0.032 // meters
    #define COUNTS_PER_REV 360 //CPR
    #define TICKS_PER_METER (WHEEL_DIAMETER * M_PI) / COUNTS_PER_REV
  
    float scale_values_exp(float target, float scale) {
      /**
      * Scales the target value from m to our experiment's scale
      * 
      * Params:
      *   target: The real value in m
      *   scale : the number of meters one cm will represent in our experiment
      */
      return target / scale / 100; // 100 cm in 1 m
    }
  =}

  m = new MotorsWithFeedback();
  state target_speed: float = 11.67 // in m/s
  state decceleration: float = 1.6 // in m/s**2
  
  state scale: float = 1 // How many meters in 1 cm
  state target_speed_scaled: float // Will be calculated on initialization
  state target_deccel_scaled: float
  
  state motor_calibrate: float = 0.95 // Scale the right motor input to match the left motors
  input start: bool // True if the line calibrators are done with calibration and robot can start driving
  
  state prev_left: float = 0 // Previous left encoder reading 
  state prev_time: float = 0 // Previous time
  output speed: float // Outputs the encoder read speed
  // Encoder to ensure constant speed
  e = new Encoders();
  
  // Input from line detector. Only using the center 3 line detectors
  input line_left: uint32_t
  input line_center: uint32_t
  input line_right: uint32_t
  state last_detect: uint32_t // Stores value of side_detect

  timer t(0, 10 ms) // Timer for triggering gyro

  // External commands
  input stop: bool
  state start_time: float // When the stop command was given. Help with decceleration timing
  input cont: bool

  // Reading tilt from accelerometer
  a = new Accelerometer();

  // Read from the encoders and accelerometer
  reaction(t) -> e.trigger, a.trigger {=
    lf_set(e.trigger, true);
    lf_set(a.trigger, true);
  =}

  // Update motor encoder values
  // Since robot is moving straight, just reading speed from left wheel
  reaction(e.left) -> m.left, speed {=
    lf_set(m.left, e.left->value);

    // Calculate speed
    float now = lf_time_logical_elapsed() / pow(10, 8); // Time in seconds
    float time_elapsed = now - self->prev_time;
    lf_set(speed, ((e.left->value - self->prev_left) / time_elapsed) * 100 * self->scale); // In m/s unscaled

    self->prev_time = now;
    self->prev_left = e.left->value;
  =}
  reaction(e.right) -> m.right {=
    lf_set(m.right, e.right->value);
  =}  

  initial mode CALIBRATING {
    // Robot waits for calibration before switching to driving mode
    reaction(start) -> m.left_speed, m.right_speed, reset(DRIVING) {=
      lf_set_mode(DRIVING);
      self->target_speed_scaled = scale_values_exp(self->target_speed, self->scale);
      self->target_deccel_scaled = scale_values_exp(self->decceleration, self->scale);
      lf_set(m.left_speed, self->target_speed_scaled);
      lf_set(m.right_speed, self->target_speed_scaled * self->motor_calibrate);
    =}
  }

  mode DRIVING {
    // Robot always driving forward on startup
    reaction(startup) -> m.left_speed, m.right_speed {=
      lf_set(m.left_speed, self->target_speed_scaled);
      lf_set(m.right_speed, self->target_speed_scaled * self->motor_calibrate);
    =}

    // Line Following
    reaction(line_left, line_center, line_right) {=
      printf("L:%f,C:%f,R:%f\n", line_left, line_center, line_right);
    =}

    // Changing mode
    reaction(stop) -> reset(STOPPING) {=
      lf_set_mode(STOPPING);
      self->start_time = lf_time_logical_elapsed() / (pow(10, 9));
    =}
  }

  mode STOPPING {
      timer update(0, 5 ms);

      reaction(update) -> m.left_speed, m.right_speed {=
          float curr_time = lf_time_logical_elapsed() / (pow(10, 9));
          // v - at
          float new_speed = self->target_speed_scaled - self->target_deccel_scaled * (curr_time - self->start_time);
          if (new_speed > 0) {
            // Set new target speed IF speed is not 0
            lf_set(m.left_speed, new_speed);
            lf_set(m.right_speed, new_speed * self->motor_calibrate);
          }
      =}

      reaction(cont) -> m.left_speed, m.right_speed, reset(DRIVING) {=
        lf_set_mode(DRIVING);
        lf_set(m.left_speed, self->target_speed_scaled);
        lf_set(m.right_speed, self->target_speed_scaled * self->motor_calibrate);
      =}
  }

}

main reactor(calibration_time: time = 5 s, sample_period: time = 100 ms, end_time: time = 20 s) {
  line = new Line()
  disp = new Display()
  robot = new Robot()

  timer t(0, sample_period)
  timer seconds(0, 1 s)  // Timer used to display seconds.
  timer end_calibration(calibration_time)
  state count: int = 0


  timer end(5 s, end_time) // TESTING PURPOSES
  timer start_again(15 s, end_time);

  reaction(startup) -> disp.line0, disp.line1, disp.line2 {=
    lf_set(disp.line0, "CALIBRATING");
    lf_set(disp.line1, "Roll robot over");
    lf_set(disp.line2, "light and dark.");
  =}

  reaction(seconds) {=
    // Just to keep track of time
    self->count++;
  =}

  reaction(robot.speed) -> disp.line3 {=
    static char buf[17];
    snprintf(buf, 17, "V:%.2fm/s,T:%.2ds", robot.speed->value, self->count);
    lf_set(disp.line3, buf);
  =}

  reaction(end_calibration) -> line.calibrate, robot.start, disp.line0, disp.line1, disp.line2 {=
    // Clearing screen
    lf_set(disp.line0, "");
    lf_set(disp.line1, "");
    lf_set(disp.line2, "");

    lf_set(line.calibrate, false);
    lf_set(robot.start, true);
  =}

  reaction(end) -> robot.stop, disp.line0 {=
    static char buf[17];
    snprintf(buf, 17, "slowing");
    lf_set(disp.line0, buf);
    lf_set(robot.stop, true);
  =}
  reaction(start_again) -> robot.cont, disp.line0 {=
    static char buf[17];
    snprintf(buf, 17, "starting");
    lf_set(disp.line0, buf);
    lf_set(robot.cont, true);
  =}

  reaction(t) -> line.trigger {=
    lf_set(line.trigger, true);
  =}

  reaction(line.reflect) -> disp.line1, robot.line_left, robot.line_center, robot.line_right {=
    static char buf1[17];
    // Larger = darker
    lf_set(robot.line_right, line.reflect->value[3]); 
    lf_set(robot.line_center, line.reflect->value[2]); 
    lf_set(robot.line_left, line.reflect->value[1]);

    // Just seeing if it's detecting or not
    bool right = line.reflect->value[3] > 500;
    bool center = line.reflect->value[2] > 500;
    bool left = line.reflect->value[1] > 500;
    snprintf(buf1, 17, "R:%d,C:%d,L:%d", right, center, left);
    lf_set(disp.line1, buf1);
  =}
}
